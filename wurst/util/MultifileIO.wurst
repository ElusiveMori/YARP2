package MultifileIO

import ErrorHandling

public enum Mode
	READ
	WRITE

string array padding

init
	padding[0] = "000"
	padding[1] = "00"
	padding[2] = "0"
	padding[3] = ""

// maximum amount of readable packets per file
constant integer PACKETS_PER_FILE = 16 	
// maximum payload size of a readable packet
constant integer MAX_PACKET_LENGTH = 209
// maximum payload size of a single file
constant integer MAX_FILE_LENGTH = PACKETS_PER_FILE * MAX_PACKET_LENGTH 
// length of a message header
constant integer MESSAGE_HEADER_LENGTH = 3
// maximum message length
constant integer MAX_MESSAGE_LENGTH = 1024 - MESSAGE_HEADER_LENGTH

/**
	Low-level static writer wrapper around the Preload API
	Supports writing directly to Preload, or can write
	readable "packets", max PACKETS_PER_FILE for a file, 
	each up to MAX_PACKET_LENGTH characters. 

	To write, first you need to call IOWriter.prepareWrite(), this will initialize
	the class for writing a new file.

	To write a simple, non-readable line use IOWriter.write()

	To write a packet that you can later read with IOReader, use IOWriter.writePacket()

	After you are done writing, call IOWriter.flushFile() with the filename you want to save it to.

	WARNING: Due to the way how WC3 handles file IO, you have to use
	this class only in one place at once. Avoid using it over time, lest you
	risk causing conflicts with other clients of the class.

	Prefer to use MessageWriter and MessageReader instead, as they are more convenient wrappers around
	these two classes.
**/
public class IOWriter
	private static constant string DATA_PADDING_1 = "\")\r\n\tcall SetPlayerName(Player("
	private static constant string DATA_PADDING_2 = "), \""
	private static constant string DATA_PADDING_3 = "\")\r\n//"
	private static constant string DATA_FOOTER = "\" )\r\nendfunction\r\nfunction AAA takes nothing returns nothing \r\n//"

	private static integer packetNumber = 0

	static function prepareWrite()
		packetNumber = 0
		PreloadGenClear()
		PreloadGenStart()

	static function write(string content)
		Preload(content)

	static function flushFile(string fileName)
		Preload(DATA_FOOTER)
		PreloadGenEnd(fileName)

	static function writePacket(string packet)
		if packetNumber == PACKETS_PER_FILE
			error("IOWriter: tried to write more packets than allowed")

		if packet.length() > MAX_PACKET_LENGTH
			error("IOWriter: tried to write more than max packet length")

		write(DATA_PADDING_1 + packetNumber.toString() + DATA_PADDING_2 + packet + DATA_PADDING_3)
		packetNumber++

/**
	Low-level static reader wrapper around the Preload API
	Supports reading packets written by IOWriter, 
	up to PACKETS_PER_FILE packets per file,
	up to MAX_PACKET_LENGTH characters per packet.

	First you need to load a file using IOReader.load(filename) and then consume
	individual packets uising IOReader.getPacket()

	IOReader.getPacket() will return null if there is no packet in that index.

	The packets are meant to be consumed immediately, as any subsequent calls
	to IOReader.load() will overwrite the previous packets.
**/
public class IOReader
	private static string array playerNames
	private static string array packets 
	
	private static function saveNames()
		for i = 0 to PACKETS_PER_FILE - 1
			playerNames[i] = players[i].getName()
			packets[i] = null

	private static function restoreNames()
		for i = 0 to PACKETS_PER_FILE - 1
			players[i].setName(playerNames[i])

	static function load(string fileName)
		saveNames()
		Preloader(fileName)

		for i = 0 to PACKETS_PER_FILE - 1
			if playerNames[i] != players[i].getName()
				packets[i] = players[i].getName()

		restoreNames()

	static function getPacket(integer i) returns string
		return packets[i]

/**
	High-level file writer that supports both single-file mode (for max of MAX_FILE_LENGTH characters) and
	folder-mode (for arbitrary sized 'files') where the data is serialized into chunks.

	MessageWriter/MessageReader are message-oriented, meaning they write and read data in 'messages', sequentially.

	MessageWriters are completely independent from each other and can be used in parallel without any issues.

	To create a new MessageWriter, use new MessageWriter(path, folderMode, owner)
	To write a message, use MessageWriter.writeMessage(message)
	Each message that you write should fit in size under MessageWriter.getAvailableSpace(), else you will receive an error
	To commit all changes, either destroy the MessageWriter, or call MessageWriter.close()
**/
public class MessageWriter
	// we need to write packets out all at once, so delay that until a whole file is ready
	private string array[PACKETS_PER_FILE] packets
	// intermediate temporary buffer
	private string buffer = ""
	private integer packetNumber = 0
	private integer fileNumber = 0
	private string path
	private boolean folderMode
	// flag to keep track if there are uncommited messages
	private boolean dirty = false
	private boolean closed = false
	private player owner

	construct(string path, boolean folderMode, player owner)
		this.path = path
		this.folderMode = folderMode
		this.owner = owner

		for i = 0 to 15
			packets[i] = null

	ondestroy
		close()
	
	private function shouldWrite() returns boolean
		return GetLocalPlayer() == owner

	/**
		Returns the message length header padded by zeroes.
	**/
	private static function getMessageLength(string payload) returns string
		let length = payload.length()
		return padding[length.toString().length()] + length.toString()

	/**
		Flushes all uncommited changes to a file and rotates to next file if necessary.
	**/
	private function flush()
		// we only need to flush if there's anything to write at all
		if dirty
			if shouldWrite()
				IOWriter.prepareWrite()

			// write out all packets due for writing and reset them
			for i = 0 to PACKETS_PER_FILE - 1
				let packet = packets[i]
				if packet != null
					if shouldWrite()
						IOWriter.writePacket(packet)
					packets[i] = null
				else
					break

			// commit to numbered file if folderMode == true, single file otherwise
			if folderMode
				if shouldWrite()
					IOWriter.flushFile(path + "/" + "chunk" + fileNumber.toString() + ".txt")
				fileNumber++
			else
				if shouldWrite()
					IOWriter.flushFile(path)

			dirty = false
			packetNumber = 0

	/**
		Switches the packet being written to the next one.
	**/
	private function advancePacket()
		if packetNumber == PACKETS_PER_FILE - 1 and not folderMode
			error("MessageWriter: exceeded maximum amount of packets per file")
		
		packets[packetNumber] = buffer
		packetNumber++
		buffer = ""

		if packetNumber == PACKETS_PER_FILE and folderMode
			flush()

	/**
		Appends to the current writing buffer, and returns anything that didn't fit into it.
	**/
	private function appendBuffer(string content) returns string
		let space = MAX_PACKET_LENGTH - buffer.length()
		var remaining = ""
		if content.length() > space
			buffer += content.substring(0, space)
			remaining = content.substring(space)
		else
			buffer += content

		// remember that we made some changes
		dirty = true

		return remaining

	/**
		Commits any remaining changes and closes the file.
	**/
	function close()
		if dirty
			if buffer.length() > 0
				advancePacket()
			
			flush()
		closed = true

	/**
		Returns the available amount of space left for next message.
		For multi-file mode, that is always the max message size.
		For single-file mode, that is either the max message size, 
		or the amount remaining for writing in the file, whichever is smaller. 

		WARNING: If you are using single-file mode, you have to check 
		that you have enough remaining space each time before writing
		a message, because each message introduces a 3-byte length header.
	**/
	function getAvailableSpace() returns integer
		var value = 0

		if not closed and folderMode
			value = MAX_MESSAGE_LENGTH
		else if not closed
			value = min(MAX_FILE_LENGTH - MESSAGE_HEADER_LENGTH - buffer.length() - packetNumber * MAX_PACKET_LENGTH, MAX_MESSAGE_LENGTH)

		return value
	/**
		Writes a single message that can be later read back using MessageReader.

		WARNING: All messages have to be under getAvailableSpace() 
		in size at the time of this call, otherwise you will receive an error.
	**/
	function writeMessage(string message)
		if closed
			error("MessageWriter: trying to write into a closed file")

		if getAvailableSpace() < (message.length() + MESSAGE_HEADER_LENGTH)
			error("MessageWriter: message is too big for this Writer")

		var payload = appendBuffer(getMessageLength(message) + message)

		// if the current message is too big to fit in the current packet, split it up
		while payload.length() > 0
			advancePacket()
			payload = appendBuffer(payload)


public class MessageReader
	private string array[PACKETS_PER_FILE] packets
	private string buffer = ""
	private integer packetNumber = 0
	private integer fileNumber = 0
	private string path
	private boolean folderMode
	private player owner
	private boolean closed = false

	construct(string path, boolean folderMode, player owner)
		